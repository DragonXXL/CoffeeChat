参考：  
[手把手教你开发生产级 IM 系统](https://mp.weixin.qq.com/s/_Direcn6tk2P2KDpncFdgQ)
[从零开始搭建瓜子 IM 系统](https://mp.weixin.qq.com/s/TUIxcg0EJC0S26gKrKqYKg)  
[一个海量在线用户即时通讯系统（IM）的完整设计](https://mp.weixin.qq.com/s?__biz=MzI1ODY0NjAwMA==&mid=2247483756&idx=1&sn=a8e3303bc573b1acaf9ef3862ef89bdd&chksm=ea044bf3dd73c2e5dcf2c10202c66d6143ec866205e9230f974fbc0b0be587926699230b6b18#rd)  
[基于消息总线的高可扩展性 IM 系统后台架构设计](https://mp.weixin.qq.com/s/a4sDH48PWTHax2uBej1Jtg)  
[低成本确保消息时序的方法](https://mp.weixin.qq.com/s/QtlgYtfek4Sv8Ss5b8ojxA)  
[别人读没读你的消息，你如何知道？](https://mp.weixin.qq.com/s/4URbQUeyTOcm1xtTwfjqUA)  
[ID 生成策略——SnowFlake](https://mp.weixin.qq.com/s/p_cANKSn5hFxHo-YzzYs-A)  
[架构成长之路：9 种高性能高可用高并发的技术架构](https://www.jianshu.com/p/b067266bbdf4)  
[golang 写的 IM 服务器](https://github.com/alberliu/goim)  
[goim v2.0-高性能聊天室](https://github.com/Terry-Mao/goim)  
[快速裂变：见证微信强大后台架构从 0 到 1 的演进历程（一）](http://www.52im.net/thread-168-1-1.html)  
[今日头条架构演进之路——高压下的架构演进专题](https://www.jianshu.com/p/6c879e132093)  
[微信技术分享：微信的海量 IM 聊天消息序列号生成实践（算法原理篇）](http://www.52im.net/thread-1998-1-1.html)

特别感谢公众号：普通程序员，**封宇**大神的系列IM分享文章🙏。

# 1 服务端设计

## 1.1 总体架构

![架构](https://raw.githubusercontent.com/xmcy0011/CoffeeChat/master/images/architecture.png)

## 1.2 逻辑架构

![架构](https://raw.githubusercontent.com/xmcy0011/CoffeeChat/master/images/architecture2.png)

客户端从Iplist服务获取接入层IP地址（也可采用域名的方式解析得到接入层IP地址），建立与接入层的连接（可能为短连接），从而实现客户端与IM服务器的数据交互；业务线服务器可以通过服务器端API建立与IM服务器的联系，向客户端推送消息；客户端上报到业务服务器的消息，IM服务器会通过mq投递给业务服务器。

### 1.2.1 用户端

移动端以 iOS 为主，全部使用 Swift 编写。后续增加顺序可能是：Flutter->Android->WebSocket 等客户端。客户端主要用来演示 SDK 功能，后续根据场景可能会考虑增加如电商、教育等 demo。

### 1.2.2 用户端 API

针对 TCP 协议，提供 IOS/Android 开发 SDK。对于 H5 页面，提供 WebSocket 接口

### 1.2.3 接入层

接入层主要任务是保持海量用户连接（接入）、攻击防护、将海量连接整流成少量 TCP 连接与逻辑层通讯。

### 1.2.4 逻辑层

逻辑层负责 IM 系统各项功能的核心逻辑实现。包括单聊（c2c）、上报(c2s)、推送(s2c)、群聊(c2g)、离线消息、登录授权、组织机构树等等内容。

### 1.2.5 存储层

存储层负责缓存或存储 IM 系统相关数据，主要包括用户状态及路由（缓存），消息数据（MySQL 也可采用 NoSql，如 MangoDB），文件数据（文件服务器）。

## 1.3 模块架构

![模块架构](https://raw.githubusercontent.com/xmcy0011/CoffeeChat/master/images/structure.png)  
除 Router 之外其他服务都是无状态设计，可以支持分布式部署。通常前期推荐每个服务部署双节点冗余，以提高可用性。

### 1.3.1 登录授权(auth)
![登录授权](https://raw.githubusercontent.com/xmcy0011/CoffeeChat/master/images/seq-login.png)  
AppServer：客户的应用服务器，非CoffeeChat提供  

1. 第三方帐号在用户注册时通过HTTP接口导入到CoffeeChat平台，传递UID、昵称（用来push推送时显示的昵称）、头像URL等。
2. 返回注册结果和token，token可以在app_server存储，直到用户修改密码后才被更新，以实现自动登录。
3. 客户端登录应用服务器，进行账号密码校验。
4. 应用服务器校验成功后，向msg_logic查询token。
5. msg_logic返回uid对应的token。
6. 客户端通过域名查询到msg_gate服务器地址（实现负载均衡）。
7. 客户端通过tcp连接msg_gate后，使用uid和token发起授权验证请求，msg_gate同步rpc调用msg_logic。
8. msg_logic验证token合法性，验证成功后把客户端状态记录在redis中并设置为在线。
9. msg_gate得到验证结果后，设置session状态，并向客户端返回验证结果。

### 1.3.2 登出(logout)
![登出](https://raw.githubusercontent.com/xmcy0011/CoffeeChat/master/images/seq-logout.png)  

1. 客户端向msg_gate发送登出请求。
2. msg_gate给客户端回复响应。
3. msg_gate通知msg_logci用户登出。

### 1.3.3 踢人(kickout)
暂不支持。

### 1.3.4 上报(c2s)
暂不支持。

### 1.3.5 推送(s2c)
![推送](https://raw.githubusercontent.com/xmcy0011/CoffeeChat/master/images/seq-s2c.png)  

1. 业务线调用push数据接口sendmsg
2. Logic向redis检索目标用户状态。如果目标用户不在线，丢弃数据（未来可根据业务场景定制化逻辑）；如果用户在线，查询到用户连接的接入层gate
3. Logic向用户所在的gate发送数据
4. Gate向用户推送数据。（如果用户不在线，通知logic用户不在线）
5. 客户端收到数据后向gate发送ack反馈
6. Gate将ack信息传递给logic层，用于其他可能的逻辑处理（如日志，确认送达等）

### 1.3.6 单聊(c2c)
![单聊](https://raw.githubusercontent.com/xmcy0011/CoffeeChat/master/images/seq-c2c.png)  

1. App1向gate1发送信息（信息最终要发给App2）
2. Gate1将信息投递给logic
3. Logic收到信息后，将信息进行存储
4. 存储成功后，logic向gate1发送ack
5. Gate1将ack信息发给App1
6. Logic检索redis，查找App2状态。如果App2未登录，流程结束
7. 如果App2登录到了gate2，logic将消息发往gate2
8. Gate2将消息发给App2（如果发现App2不在线，丢弃消息即可，这种概率极低，后续离线消息可保证消息不丢）
9. App2向gate2发送ack
10. Gate2将ack信息发给logic
11. Logic将消息状态设置为已送达。

注：在第6步和第7步之间，启动计时器（DelayedQueue或哈希环，时间如5秒），计时器时间到后，探测该条消息状态，如果消息未送达，考虑通过APNS、米推、个推进行推送

### 1.3.7 群聊(c2g)
采用扩散写（而非扩散读）的方式。  
群聊是多人社交的基本诉求，一个群友在群内发了一条消息：  
（1）在线的群友能第一时间收到消息  
（2）离线的群友能在登陆后收到消息  
由于“消息风暴扩散系数”的存在，群消息的复杂度要远高于单对单消息。  
群基础表：用来描述一个群的基本信息  
im_group_msgs(group_id, group_name,create_user, owner, announcement, create_time)  
群成员表：用来描述一个群里有多少成员  
im_group_users(group_id, user_id)  
用户接收消息表：用来描述一个用户的所有收到群消息（与单对单消息表是同一个表）  
im_message_recieve（msg_id,msg_from,msg_to, group_id，msg_seq, msg_content, send_time, msg_type, deliverd, cmd_id）  
用户发送消息表：用来描述一个用户发送了哪些消息  
im_message_send (msg_id,msg_from,msg_to, group_id，msg_seq, msg_content, send_time, msg_type, cmd_id)  
业务场景举例：  
（1）一个群中有x,A,B,C,D共5个成员，成员x发了一个消息  
（2）成员A与B在线，期望实时收到消息  
（3）成员C与D离线，期望未来拉取到离线消息  
群聊流程如下图所示  
![群聊](https://raw.githubusercontent.com/xmcy0011/CoffeeChat/master/images/seq-c2g.png)  
1. X向gate发送信息（信息最终要发给这个群，A、B在线）
2. Gate将消息发给logic
3. 存储消息到im_message_send表，按照msg_from水平分库
4. 回ack
5. 回ack
6. Logic检索数据库（需要使用缓存），获得群成员列表
7. 存储每个用户的消息数据（用户视图），按照msg_to水平分库(并发、批量写入)。
8. 查询用户在线状态及位置
9. Logic向gate投递消息
10. Gate向用户投递消息
11. App返回收到消息的ack信息
12. Gate向logic传递ack信息
13. 向缓存（Hash）中更新收到ack的时间。然后在通过一个定时任务，每隔一定时间，将数据更新到数据库（注意只需要写入时间段内有变化的数据）。

### 1.3.8 拉取离线消息(pull)

参考文章（基于TimeLine模型的消息同步机制 https://mp.weixin.qq.com/s/0eKfIRy8zpCpMrrF15Uigg）  
目前CoffeeChat基于简单的消息同步方法：
1. 把消息存储到mysql
2. 向在线用户推送消息（离线则走push通道）
3. 在线用户返回收到消息的ack信息

对于离线用户，登录后直接拉取离线消息即可，包含2部分：一次性查询会话列表和按需拉取某个会话下的历史聊天记录，后续再考虑增加基于TimeLine模型的消息同步功能。

#### 1）查询会话列表(session)，包含未读计数
![会话列表](https://raw.githubusercontent.com/xmcy0011/CoffeeChat/master/images/seq-session.png)  

1. 客户端向msg_gate请求会话列表。
2. msg_logic异步处理查询请求，通过线程池+消息队列的方式。
3. msg_logic从mysql中获取用户的所有会话列表，每个会话对应的最新消息id和内容等。
4. msg_logic从redis中补全每个会话的未读消息数量。
5. msg_logic回复响应。
6. msg_gate转发响应给客户端。

#### 2）查询历史消息(msglog)
![历史消息](https://raw.githubusercontent.com/xmcy0011/CoffeeChat/master/images/seq-msglog.png)  

1. App端登录成功，点击某个聊天后，向IM系统发起拉历史离线消息请求。传递3个主要参数，uid表明用户；end_msg_id表明当前收到的最小消息id（如果没收到过消息，或拿不到最小消息id则为0）即可；limit表示每次拉取条数（这个值也可以由服务器端控制）。
2. end_msg_id为0，查询最新的20条数据。
3. im_server查询用户前20条离线消息。
4. 将离线消息推给用户。假设这20条离线消息最后一条（最小）end_msg_id=110。
5. App得到数据，判断得到的数据不为空（消息数目返回的数值等于请求的limit），继续发起拉取操作。end_msg_id=110(取得到的离线消息中最后的一条，即ID最小的一条)。
6. 无。
7. 查询end_msg_id<110的钱20条离线数据。
8. 返回给App。
9. N-1查询end_msg_id>10的离线数据，不足20条（没有离线数据了）。 
10. N将数据返回App，App判断拉取不足20条数据，结束离线拉取过程。

注：上述是拉取所有聊天记录的完整过程，实际中是根据用户滑动操作按需拉取的。

## 1.2 推送平台

iOS：使用苹果官方的 APNS 推送，到达率有保障  
Android：  
第一种方案：根据手机来选择对应厂商的推送平台，比如华为、小米、OV、魅族等，到达率相对有保障，但是也会丢。  
第二种方案：也可以选择第三方厂商一键支持所有手机，比如极光、米推、个推，免费的效果很差并且有条数限制。  
第三种方案：可以选择真后台保活或者申请应用白名单。  
以上方案可以结合使用，总体而言，推送比较头疼。和微信、QQ等不能比，很多APP会彼此唤醒，手机厂商会选择把2者加入系统白名单等，所以才有那么高的消息到达率。

# 2 协议设计

具体见 pb 文件夹。
CIMDef.proto：消息和数据模型定义
CIMLogin.proto：登录认证业务。
CIMList.proto：列表业务。会话（包括未读计数）、历史离线消息等
CIMMessage.proto：消息业务。收发文本、图片、表情、声音、视频、文件、位置等

# 3 存储设计
